// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: step_runs.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStepRun = `-- name: CreateStepRun :one
INSERT INTO step_runs (
    id, run_id, step_index, name, agent_id, status,
    input, output, requires_approval, timeout_seconds,
    max_retries, retry_count, error, tokens_in, tokens_out,
    step_order, started_at, completed_at, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19
)
RETURNING id, run_id, step_index, name, agent_id, status, input, output, requires_approval, timeout_seconds, max_retries, retry_count, error, tokens_in, tokens_out, step_order, started_at, completed_at, created_at
`

type CreateStepRunParams struct {
	ID               string             `json:"id"`
	RunID            string             `json:"run_id"`
	StepIndex        int32              `json:"step_index"`
	Name             string             `json:"name"`
	AgentID          *string            `json:"agent_id"`
	Status           string             `json:"status"`
	Input            []byte             `json:"input"`
	Output           []byte             `json:"output"`
	RequiresApproval bool               `json:"requires_approval"`
	TimeoutSeconds   *int32             `json:"timeout_seconds"`
	MaxRetries       *int32             `json:"max_retries"`
	RetryCount       *int32             `json:"retry_count"`
	Error            *string            `json:"error"`
	TokensIn         *int32             `json:"tokens_in"`
	TokensOut        *int32             `json:"tokens_out"`
	StepOrder        int32              `json:"step_order"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateStepRun(ctx context.Context, arg CreateStepRunParams) (StepRun, error) {
	row := q.db.QueryRow(ctx, createStepRun,
		arg.ID,
		arg.RunID,
		arg.StepIndex,
		arg.Name,
		arg.AgentID,
		arg.Status,
		arg.Input,
		arg.Output,
		arg.RequiresApproval,
		arg.TimeoutSeconds,
		arg.MaxRetries,
		arg.RetryCount,
		arg.Error,
		arg.TokensIn,
		arg.TokensOut,
		arg.StepOrder,
		arg.StartedAt,
		arg.CompletedAt,
		arg.CreatedAt,
	)
	var i StepRun
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.StepIndex,
		&i.Name,
		&i.AgentID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequiresApproval,
		&i.TimeoutSeconds,
		&i.MaxRetries,
		&i.RetryCount,
		&i.Error,
		&i.TokensIn,
		&i.TokensOut,
		&i.StepOrder,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteStepRunsByRunID = `-- name: DeleteStepRunsByRunID :exec
DELETE FROM step_runs
WHERE run_id = $1
`

func (q *Queries) DeleteStepRunsByRunID(ctx context.Context, runID string) error {
	_, err := q.db.Exec(ctx, deleteStepRunsByRunID, runID)
	return err
}

const getStepRun = `-- name: GetStepRun :one
SELECT id, run_id, step_index, name, agent_id, status, input, output, requires_approval, timeout_seconds, max_retries, retry_count, error, tokens_in, tokens_out, step_order, started_at, completed_at, created_at FROM step_runs
WHERE id = $1
`

func (q *Queries) GetStepRun(ctx context.Context, id string) (StepRun, error) {
	row := q.db.QueryRow(ctx, getStepRun, id)
	var i StepRun
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.StepIndex,
		&i.Name,
		&i.AgentID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequiresApproval,
		&i.TimeoutSeconds,
		&i.MaxRetries,
		&i.RetryCount,
		&i.Error,
		&i.TokensIn,
		&i.TokensOut,
		&i.StepOrder,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listStepRunsByRunID = `-- name: ListStepRunsByRunID :many
SELECT id, run_id, step_index, name, agent_id, status, input, output, requires_approval, timeout_seconds, max_retries, retry_count, error, tokens_in, tokens_out, step_order, started_at, completed_at, created_at FROM step_runs
WHERE run_id = $1
ORDER BY step_index ASC
`

func (q *Queries) ListStepRunsByRunID(ctx context.Context, runID string) ([]StepRun, error) {
	rows, err := q.db.Query(ctx, listStepRunsByRunID, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StepRun{}
	for rows.Next() {
		var i StepRun
		if err := rows.Scan(
			&i.ID,
			&i.RunID,
			&i.StepIndex,
			&i.Name,
			&i.AgentID,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.RequiresApproval,
			&i.TimeoutSeconds,
			&i.MaxRetries,
			&i.RetryCount,
			&i.Error,
			&i.TokensIn,
			&i.TokensOut,
			&i.StepOrder,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStepRun = `-- name: UpdateStepRun :one
UPDATE step_runs
SET
    status = $2,
    input = $3,
    output = $4,
    retry_count = $5,
    error = $6,
    tokens_in = $7,
    tokens_out = $8,
    started_at = $9,
    completed_at = $10
WHERE id = $1
RETURNING id, run_id, step_index, name, agent_id, status, input, output, requires_approval, timeout_seconds, max_retries, retry_count, error, tokens_in, tokens_out, step_order, started_at, completed_at, created_at
`

type UpdateStepRunParams struct {
	ID          string             `json:"id"`
	Status      string             `json:"status"`
	Input       []byte             `json:"input"`
	Output      []byte             `json:"output"`
	RetryCount  *int32             `json:"retry_count"`
	Error       *string            `json:"error"`
	TokensIn    *int32             `json:"tokens_in"`
	TokensOut   *int32             `json:"tokens_out"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateStepRun(ctx context.Context, arg UpdateStepRunParams) (StepRun, error) {
	row := q.db.QueryRow(ctx, updateStepRun,
		arg.ID,
		arg.Status,
		arg.Input,
		arg.Output,
		arg.RetryCount,
		arg.Error,
		arg.TokensIn,
		arg.TokensOut,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i StepRun
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.StepIndex,
		&i.Name,
		&i.AgentID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.RequiresApproval,
		&i.TimeoutSeconds,
		&i.MaxRetries,
		&i.RetryCount,
		&i.Error,
		&i.TokensIn,
		&i.TokensOut,
		&i.StepOrder,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}
